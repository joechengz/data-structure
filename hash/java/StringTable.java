
//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {
    
    //
    // Create an empty table big enough to hold maxSize records.
    //
	
	Record[] table=new Record[100];
	int count=0;
    public StringTable(int maxSize) 
    {
//    	int n=0;
//    	while(maxSize/2!=0)
//    	{
//    		n++;
//    		maxSize=maxSize/2;
//    	}
//    	n=n+2;
//    	table=new Record[(int)Math.pow(2, n)];
    	int n=8;
    	table=new Record[n];
    }
    

    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
//  public boolean insert(Record r) 
//  { 
//  	int v=toHashKey(r.key);
//  	int base = baseHash(toHashKey(r.key));
//  	int step = stepHash(toHashKey(r.key));
//  	int s=table.length;
//  	int k=base%s;
//  	for(int i=0;i<s;i++){
//  	if(table[k]==null)
//  	{
//  		table[k]=r;
//  		r.hashValue=v;
//  		return true;
//  	}
//  	else
//  	{
//  		k=(k+step)%s;
//  	}
//  	}
//	return false; 
//  } 
	public void resize()
	{
		Record[] oldtable=table;
		int osize=table.length;
		table= new Record[osize*2];
		int nsize=table.length;
		int base=0;
		int step=0;
		int slot=0;
		for(int k=0;k<osize;++k)
		{
			if(oldtable[k]!=null&&oldtable[k].key!="deleted")
			{
			base = baseHash(toHashKey(oldtable[k].key));
		  	step = stepHash(toHashKey(oldtable[k].key));
		  	slot = base%nsize;
		  	while(table[slot]!=null)
		  	{
		  		slot=(slot+step%nsize)%nsize;
		  	}
		  	table[slot]=oldtable[k];
			}
		}
		
	}

	
	public boolean insert(Record r)
	{
		if((double)count/table.length>=0.25)
		{
			resize();
		}
		int v=toHashKey(r.key);
		int base = baseHash(toHashKey(r.key));
    	int step = stepHash(toHashKey(r.key));
    	int maxSize=table.length;
    	int k=base%maxSize;
      	for(int i=0;i<maxSize;i++){
      	  	if(table[k]==null)
      	  	{
      	  		table[k]=r;
      	  		r.hashValue=v;
      	  		count++;
      	  		return true;
      	  	}
      	  	else
      	  	{
      	  		k=(k+step%maxSize)%maxSize;
      	  	}
      	  	}
      		return false; 
		}
//    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	int base = baseHash(toHashKey(r.key));
    	int step = stepHash(toHashKey(r.key));
    	int maxSize=table.length;
    	int k=base%maxSize;
    	for(int i=0;i<maxSize;i++)
    	{
    		if(table[k].key!=null)
    		{
    			if(table[k].key.equals(r.key))
    			{
    				table[k].key="Deleted";
    				table[k].positions.add(0);
    			}
    			else
    			{
    				k=(k+step%maxSize)%maxSize;
    			}
    		}
    	}
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int num = toHashKey(key);
    	int base = baseHash(toHashKey(key));
    	int step = stepHash(toHashKey(key));
    	int maxSize=table.length;
    	int k=base%maxSize;
    	for(int i=0;i<maxSize;i++)
    	{
    		if(table[k]==null)
    		{
    			return null;
    		}
    		else if(table[k].hashValue==num)
    		{
    			if(table[k].key.equals(key)){
    			return table[k];
    			}
    			else
        		{
        			k=(k+step%maxSize)%maxSize;
        		}
    		}
//    		else if(table[k].key.equals(key))
//    		{
//    			return table[k];
//    		}
    		else
    		{
    			k=(k+step%maxSize)%maxSize;
    		}
    	}
    	return null;
    }
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
	// Fill in your own hash function here
    	double n1=(Math.sqrt(3))/2;
    	double h1=Math.floor(table.length*(hashKey*n1-Math.floor(hashKey*n1)));
	return (int)h1;
    }
    
    int stepHash(int hashKey)
    {
	// Fill in your own hash function here
    	double n2=(Math.sqrt(5)-1)/2;
    	double h2=Math.floor(table.length*(hashKey*n2-Math.floor(hashKey*n2)));
	return (int)h2;
    }
}